"""
MUNICODE POLICY CHATBOT

Gets answer to policy questions based on municode using gemini.

Authors: Chenghao Li
Org: University of Toronto - School of Cities
"""

import scrapers.municode_scraper as municode
import os
import time
import json
from pydantic import BaseModel
from dotenv import load_dotenv
from google import genai
from google.genai import types
from google.genai.errors import ServerError

load_dotenv()
GOOGLE_API_KEY = os.getenv('GOOGLE') # google cloud api key
LOGGING = True # whether or not log.md is generated
LOG_PROMPTS = False # logs prompts generated by the chatbot

# schema for responses
RESPONSE_SCHEMA = {
    "type": "object",
    "properties": {
        "binary_response": {"type": "boolean"},
        "numeric_response": {
            "type": "object",
            "properties": {
                "number": {"type": "number"},
                "units": {"type": "string"}
            },
            "required": ["number", "units"]
        },
        "categorical_response": {
            "type": "string"
        },
        "conditional_response": {
            "type": "array",
            "minItems": 2,
            "items": {
                "type": "object",
                "properties": {
                    "condition": {"type": "string"},
                    "conditioned_response": {"type": "string"}
                },
                "required": ["condition", "conditioned_response"]
            }
        },
        "sources": {
            "type": "array",
            "minItems": 1,
            "items": {
                "type": "object",
                "properties": {
                    "source_url": {"type": "string"},
                    "page_name": {"type": "string"},
                    "relevant_quotation_from_source": {"type": "string"}
                },
                "required": ["source_url", "relevant_quotation_from_source", "page_name"]
            }
        }
    },
    "required": ["sources"]
}

# TODO: use enums for titles
# Schema for the sorter
SORTER_SCHEMA = {
    "type": "array",
    "minItems": 1,
    "items": {
        "type": "object",
        "properties": {
            "name": {"type": "string"},
            "relevance_rating": {"type": "number"}
        },
        "required": ["name", "relevance_rating"]
    }
}


# grounding with google search
GROUNDING = types.Tool(
    google_search=types.GoogleSearch()
)

# gemini configs
CONFIGS = {
    "thinking": types.GenerateContentConfig(
        system_instruction=[
             "You are a helpful municipality policy analyst bot.",
            """Try to use the links the user provides as much as possible and to not stray from the chapter/article/section unless for verification/grounding purposes. Extract relevant information, then ground your answer based on the extraced data. Only use search to check your work or ground your answer. Make sure you check your work. Use and make sure to cite specific sources when coming up with your reponse. Your sources must come from official government websites or from a municipal code website like municode.""",
            """Quotes must be exact content from inside the provided link with no modification.
Whenever you provide a quote, double check that the quote is within the link you specified. You must be able to specify one quote from within the provided links.
Try to keep the quotes short, only containing the most relevant and important points.""",
            """Please follow the formating tips below for the answer section:

1. Numeric question:
    - Answer should only contain the number and the units.
    - Example: 5 eggs

2. Binary question:
    - Answer should only contain "(YES)" for yes or "(NO)" for no and "(NONE)" for no answer found.
    - If you find no answers and encounter nothing of use, don't respond with "(NO)" and instead respond with "(NONE)"
    - DO NOT GIVE FULL RESPONSES
    - Example: Q: Are ADUs required to provide parking space? A: "(YES)"

3. Categorical Questions:
    - Provide ONLY the title or name requested.
    - Example: Q: Which entity acts as the special permit granting authority for multi-family housing? A: "Zoning Board of Appeals"

4. Conditional:
    - If the answer based on the information from the link is ambiguous or if there is no single answer, provide all the answers you find and the cases where each answer would apply.
    - Provide the condition and the result of that condition.
    - Example: Q: how many eggs should I use to feed my family? A: "4 people: 6 eggs, 5 people: 7 eggs, 6+ people: 10 eggs"

5. No answer/answers found
    - Reply ONLY with the word “(NONE)” and nothing else.

Please provide one or more quotes from which you derived your answer in the format shown below:

"(ANSWER): 'answer'

(QUOTE): ```'exact quote from url 1'``` [('name of page')]('url 1')

(QUOTE): ```'exact quote from url 2'``` [('name of page')]('url 2')

..."

Examples: 
    Question: When/Where is it unlawful to solicit someone?
    Response: (ANSWER): Within 30 feet of entrance/exit of bank/credit union, check cashig business, automated teller machine, Parking lots or parking structures after dark, Public transportation vehicle

    (QUOTE): ```4.12.1230 - Prohibited solicitation at specific locations.

    (a) It shall be unlawful for any person to solicit within thirty (30) feet of any entrance or exit of a bank, credit union, check cashing business or within thirty (30) feet of an automated teller machine.

    (b) It shall be unlawful for any person to solicit in any public transportation vehicle.

    (c) Parking lots. It shall be unlawful for any person to solicit in any parking lot or parking structure any time after dark. "After dark" means any time for one-half hour after sunset to one-half hour before sunrise.``` [(Article 14. - Soliciting and Aggressive Solicitation)](https://library.municode.com/ca/tracy/codes/code_of_ordinances?nodeId=TIT4PUWEMOCO_CH4.12MIRE_ART14SOAGSO)

    Question: Can I direct traffic if I'm not police?
    Response: (ANSWER): (NO)
    (QUOTE): ``` 3.08.050 - Direction of traffic.

No person, other than an officer of the Police Department or a person deputized or authorized by the Chief of Police or other person acting in any official capacity, or by authority of law shall direct or attempt to direct traffic by voice, hand or other signal.

(Prior code § 3-2.203)``` [(Chapter 3.08 - TRAFFIC REGULATIONS)](https://library.municode.com/ca/tracy/codes/code_of_ordinances?nodeId=TIT3PUSA_CH3.08TRRE)
""",
            "Keep your responses clear and concise."
            "Make sure to check your work"
        ],
        thinking_config=types.ThinkingConfig(
            include_thoughts=True,
            thinking_budget=-1
        ),
        tools=[GROUNDING],
        temperature=0.05,
        topP=0.15
    ),
    "structurer": types.GenerateContentConfig(
        system_instruction=[
            """You are a helpful municipality policy analyst bot.""",
            """You will be given a response to a question. Please take that response and format it accordingly."""
        ],
        response_mime_type='application/json',
        response_schema=RESPONSE_SCHEMA,
        temperature=0.05,
        topP=0.15
    ),
    "sorter": types.GenerateContentConfig(
        system_instruction=[
            """You are a helpful municipality policy analyst bot.""",
            """You will be asked to sort all the names of titles/chapters/articles/sections in terms of most relevant to least relevant from a list of names based on a question.""",
            """Add a relevance rating for each name. (decimal number from 0-10 with 0 being the least relevant)""",
            """Avoid anything that is repealed, obsolete or are sections similar to "summary history table", "dispostion table" or "city municipal code". Anything not relevant enough should be ignored (Don't include anything with low relevance).""",
            """The name should be the chapters/articles/sections names with no extra spaces, punctuation, only the exact names of the chapters/articles/sections in a list ordered from best to worst (most relevant to least relevant) with no modification.""",
            """Terms like "inclusionary zoning", "density bonus", "commercial linkage fees", etc. typically are relevant to housing titles/chapters NOT zoning ones."""
        ],
        response_mime_type='application/json',
        response_schema=SORTER_SCHEMA,
        temperature=0.05,
        topP=0.15
    )
}

# model options
MODELS = {
    "thinking": "gemini-2.5-flash",
    "fast": "gemini-2.0-flash-lite"
}

def log(text):
    """
    Log text into log.txt file for debugging/testing purposes

    :param text: input text
    :return:
    """
    if not LOGGING:
        return
    with open("log.md", "a", encoding="utf-8") as f:
        f.write(text)

def gemini_query(client, prompt, config, model):
    """
    Send thinking query to gemini

    :param client: gemini client
    :param prompt: prompt for gemini
    :param config: gemini config
    :return: dictionary containing "think" and "response"
    """

    try:
        result = {
            "think": "",
            "response": "" 
        }
        if LOG_PROMPTS:
            log(f"### Prompt:\n\n{prompt}\n\n-------------------\n\n")

        # gemini config

        # incremental response
        for chunk in client.models.generate_content_stream(
            model=model,
            contents=prompt,
            config=config
        ):
            if chunk.candidates and chunk.candidates[0].content.parts:
                for part in chunk.candidates[0].content.parts:
                    if not part or not part.text:
                        continue
                    if part.thought:
                        if not result["think"]:
                            log(f"### Thinking:\n\n")
                        result["think"] += part.text
                        log(part.text)
                    else:
                        if not result["response"]:
                            log(f"### Response:\n\n")
                        result["response"] += part.text
                        log(part.text)
        log("\n\n-------------------\n\n")
        return result
    except ServerError as e:
        log(f"\n\n#### ERROR OCCURED ({e}). RETRYING IN 10 SECONDS\n\n")
        time.sleep(10)
        log(f"#### RETRYING...\n\n")
        return gemini_query(client, prompt, config, model)

def key_list(dict, seperator=", "):
    """
    Takes dictionary/list and creates a string containing all the keys/elements in a list seperated with the seperator

    :param dict: input dictionary/list
    :param seperator: string to seperate each element
    :return: list as a string
    """

    result = ""
    for key in dict:
        result += key + seperator
    result = result[:-(len(seperator))]
    return result

def answer(muni_nav, client, muni, url, query, depth=0, definitions=""):
    """
    Accesses the title/chapter/article/section names recursively until answer is found to query

    :param muni_nav: municode scraper object
    :param client: gemini client
    :param muni: current municipality
    :param url: url to page to scrape from
    :param query: input question
    :param depth: depth of item. (0-title, 2-chapter, 3-article/section)
    :param definitions: link to the most relevant definitions section (usually empty)
    :return: prompt, answer to query, structured response
    """

    muni_names = None
    while not muni_names:
        muni_nav.go(url)
        muni_names = muni_nav.scrape_codes(depth) # get title/chapters/articles/section
        if not muni_names:
            log(f"#### FAILED. RETRYING...\n\n")
    definitions_link = definitions
    for name in muni_names: # find definitions, if exists.
        if "definition" in name.lower():
            definitions_link = muni_names[name]
            muni_names.pop(name)
            break

    name_list = key_list(muni_names)

    log(f"## Selecting title/chapters/articles/sections...\n\n")

    prompt = f"""Query: "{query}".
Here is the list of title/chapters/articles/sections:
{name_list}."""

    response = gemini_query(client, prompt, CONFIGS["sorter"], MODELS["fast"]) # prompt for relevant title/chapters/articles/section

    response_json = json.loads(response["response"])
    response_json.sort(key=lambda x: x['relevance_rating'], reverse=True) # sorts the list based on relevance_rating

    if not len(response_json) or response_json[0]["relevance_rating"] < 4: # return None if none of the reponses are relevant enough
        return None, None, None

    for attempt in response_json:
        current_name = attempt["name"]
        if current_name in muni_names:
            log(f"### Navigating to [{current_name}]({muni_names[current_name]})\n\n")
            response = {}
            if not depth or muni_nav.contains_child(): # if theres child entries, we'll use those instead to get our answer
                if not depth:
                    depth += 1
                prompt, response, structured_response = answer(muni_nav, client, muni, muni_names[current_name], query, depth + 1, definitions_link)
            else:
                log("## ANSWERING\n\n")
                prompt = f"""Answer the following question from the link {muni_nav.get_url()}{f", with the definitions of terms stored here:{definitions_link}" if definitions_link else ""} for the municipality of {muni}.

Question: {query}"""
                response = gemini_query(client, prompt, CONFIGS["thinking"], MODELS["thinking"]) # prompt for answer to query
                if "(NONE)" in response["response"]:
                    response = None
                else:
                    structured_response = gemini_query(client, response["response"], CONFIGS["structurer"], MODELS["fast"])
            if response: # If no answer, continue, else, continue and look at next title/chapter/article/section
                return prompt, response, structured_response
    return None, None, None

def main():
    state = "california"
    muni = "milpitas"
    query = "Where am i allowed to solicit?" #"When it comes to affordable housing, are there Inclusionary Zoning rules?" 
    client = genai.Client(api_key=GOOGLE_API_KEY)
    municode_nav = municode.MuniCodeCrawler() # open crawler
    if LOGGING:
        with open("log.md", "w", encoding="utf-8") as f: # for testing purposes
            f.write(f"# LOG\n\n")

    muni_states = None
    while not muni_states:
        muni_states = municode_nav.scrape_states() # grab states
        if not muni_states:
            log(f"#### FAILED TO GET STATES, RETRYING.\n\n")
            municode_nav.go()
    
    state = state or input("State: ").lower()
    log(f"#### State: {state}\n\n")
    
    muni_cities = None
    while not muni_cities:
        municode_nav.go(muni_states[state]) # go to selected state
        muni_cities = municode_nav.scrape_cities() # grab cities
        if not muni_cities:
            log(f"#### FAILED TO GET CITIES, RETRYING.\n\n")
    #for city in muni_cities:
        #print(city)
    
    muni = muni or input("Municipality: ").lower()
    log(f"#### Municipality: {muni}\n\n")

    query = query or input("Question: ")
    log(f"#### Question: {query}\n\n-------------------\n\n")

    response = answer(municode_nav, client, muni, muni_cities[muni], query) # find relevant chapter/article and get answer
    contents = [
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text=response[0])
            ]
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text=response[1]["think"]),
                types.Part.from_text(text=response[1]["response"])
            ]
        )
    ]
    response = response[1]
    # allow user to respond and converse with model
    while (True):
        prompt = input("Respond: ")
        log(f"### User asks:\n\n{prompt}\n\n-------------------\n\n")
        if prompt == "/structure":
            print(gemini_query(client, response["response"], CONFIGS["structurer"], MODELS["fast"]))
        else:
            contents.append(
                types.Content(
                    role="user",
                    parts=[
                        types.Part.from_text(text=prompt)
                    ]
                )
            )
            response = gemini_query(client, contents, CONFIGS["thinking"], MODELS["thinking"])
            contents.append(
                types.Content(
                    role="model",
                    parts=[
                        types.Part.from_text(text=response["think"]),
                        types.Part.from_text(text=response["response"])
                    ]
                )
            )

    


if __name__ == "__main__":
    main()