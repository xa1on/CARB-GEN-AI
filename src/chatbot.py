"""
MUNICODE POLICY CHATBOT

Gets answer to policy questions based on municode using gemini.

Authors: Chenghao Li
Org: University of Toronto - School of Cities
"""

import scrapers.municode_scraper as municode
import os
import time
import json
from pydantic import BaseModel
from dotenv import load_dotenv
from google import genai
from google.genai import types
from google.genai.errors import ServerError

load_dotenv()
GOOGLE_API_KEY = os.getenv('GOOGLE') # google cloud api key
LOGGING = True # whether or not log.md is generated
LOG_PROMPTS = False # logs prompts generated by the chatbot

# schema for responses
RESPONSE_SCHEMA = {
    "type": "object",
    "properties": {
        "binary_response": {"type": "boolean"},
        "numeric_response": {
            "type": "object",
            "properties": {
                "number": {"type": "number"},
                "units": {"type": "string"}
            },
            "required": ["number", "units"]
        },
        "categorical_response": {
            "type": "string"
        },
        "conditional_response": {
            "type": "array",
            "minItems": 1,
            "items": {
                "type": "object",
                "properties": {
                    "condition": {"type": "string"},
                    "conditioned_response": {"type": "string"}
                },
                "required": ["condition", "conditioned_response"]
            }
        },
        "sources": {
            "type": "array",
            "minItems": 1,
            "items": {
                "type": "object",
                "properties": {
                    "source_url": {"type": "string"},
                    "relevant_quotation_from_source": {"type": "string"}
                },
                "required": ["source_url", "relevant_quotation_from_source"]
            }
        }
    },
    "required": ["sources"]
}

# TODO: use enums for titles
# Schema for the sorter
SORTER_SCHEMA = {
    "type": "array",
    "minItems": 1,
    "items": {
        "type": "object",
        "properties": {
            "name": {"type": "string"},
            "relevance_rating": {"type": "number"}
        },
        "required": ["name", "relevance_rating"]
    }
}


# grounding with google search
GROUNDING = types.Tool(
    google_search=types.GoogleSearch()
)

# gemini configs
CONFIGS = {
    "thinking": types.GenerateContentConfig(
        system_instruction=[
            "You are a helpful municipality policy analyst bot.",
            """You will be prompted with questions or claification. When prompted with a question, return response accordingly.""",
            """Ensure that you specify whether or not the answer to the question being asked is binary, numeric, categorical, or conditional.""",
            """If no binary, numeric, categorical, or conditional answers are found, reply with the word "(NONE)\" and nothing else.""",
            """Try to use the links the user provides as much as possible and to not stray from the chapter/article/section unless for verification/grounding purposes. Extract relevant information, then ground your answer based on the extraced data. Only use search to check your work or ground your answer. Make sure you check your work. Use and make sure to cite specific sources when coming up with your reponse. Your sources must come from official government websites or from a municipal code website like municode.""",
            """You must find and use at least one quotation, unless no answer is found.""",
            """Quotations must be exact content from inside a link with no modification. Quotations must contain the exact wording of the document.
Whenever you provide a quote, double check that the quote is within the link you specified. You must be able to specify one quote from within the provided links.
Try to keep the quotes short, only containing the most relevant and important points.""",
"""Citations and quotations are required. Ensure you include the link to any sources you use after each quotation. YOU MUST USE WEB LINKS.""",
"""Make sure to check your work."""
        ],
        thinking_config=types.ThinkingConfig(
            include_thoughts=True,
            thinking_budget=-1
        ),
        tools=[GROUNDING],
        temperature=0.05,
        topP=0.15
    ),
    "structurer": types.GenerateContentConfig(
        system_instruction=[
            """You are a helpful municipality policy analyst bot.""",
            """You will be given a response to a question. Please take that response and format it accordingly."""
        ],
        response_mime_type='application/json',
        response_schema=RESPONSE_SCHEMA,
        temperature=0.05,
        topP=0.15
    ),
    "sorter": types.GenerateContentConfig(
        system_instruction=[
            """You are a helpful municipality policy analyst bot.""",
            """You will be asked to sort all the names of titles/chapters/articles/sections in terms of most relevant to least relevant from a list of names based on a question.""",
            """Add a relevance rating for each name. (decimal number from 0-10 with 0 being the least relevant)""",
            """Avoid anything that is repealed, obsolete or are sections similar to "summary history table", "dispostion table" or "city municipal code". Anything not relevant enough should be ignored (Don't include anything with low relevance).""",
            """The name should be the chapters/articles/sections names with no extra spaces, punctuation, only the exact names of the chapters/articles/sections in a list ordered from best to worst (most relevant to least relevant) with no modification.""",
            """Terms like "inclusionary zoning", "density bonus", "commercial linkage fees", etc. typically are relevant to housing titles/chapters NOT zoning ones."""
        ],
        response_mime_type='application/json',
        response_schema=SORTER_SCHEMA,
        temperature=0.05,
        topP=0.15
    )
}

# model options
MODELS = {
    "thinking": "gemini-2.5-flash",
    "fast": "gemini-2.0-flash-lite"
}

def log(text):
    """
    Log text into log.txt file for debugging/testing purposes

    :param text: input text
    :return:
    """
    if not LOGGING:
        return
    with open("log.md", "a", encoding="utf-8") as f:
        f.write(text)

def gemini_query(client, prompt, config, model):
    """
    Send thinking query to gemini

    :param client: gemini client
    :param prompt: prompt for gemini
    :param config: gemini config
    :return: dictionary containing "think" and "response"
    """

    try:
        result = {
            "think": "",
            "response": "" 
        }
        if LOG_PROMPTS:
            log(f"### Prompt:\n\n{prompt}\n\n-------------------\n\n")

        # gemini config

        # incremental response
        for chunk in client.models.generate_content_stream(
            model=model,
            contents=prompt,
            config=config
        ):
            if chunk.candidates and chunk.candidates[0].content.parts:
                for part in chunk.candidates[0].content.parts:
                    if not part or not part.text:
                        continue
                    if part.thought:
                        if not result["think"]:
                            log(f"### Thinking:\n\n")
                        result["think"] += part.text
                        log(part.text)
                    else:
                        if not result["response"]:
                            log(f"### Response:\n\n")
                        result["response"] += part.text
                        log(part.text)
        log("\n\n-------------------\n\n")
        return result
    except ServerError as e:
        log(f"\n\n#### ERROR OCCURED ({e}). RETRYING IN 10 SECONDS\n\n")
        time.sleep(10)
        log(f"#### RETRYING...\n\n")
        return gemini_query(client, prompt, config, model)

def key_list(dict, seperator=", "):
    """
    Takes dictionary/list and creates a string containing all the keys/elements in a list seperated with the seperator

    :param dict: input dictionary/list
    :param seperator: string to seperate each element
    :return: list as a string
    """

    result = ""
    for key in dict:
        result += key + seperator
    result = result[:-(len(seperator))]
    return result

def answer(muni_nav, client, muni, url, query, depth=0, definitions=""):
    """
    Accesses the title/chapter/article/section names recursively until answer is found to query

    :param muni_nav: municode scraper object
    :param client: gemini client
    :param muni: current municipality
    :param url: url to page to scrape from
    :param query: input question
    :param depth: depth of item. (0-title, 2-chapter, 3-article/section)
    :param definitions: link to the most relevant definitions section (usually empty)
    :return: prompt, answer to query, structured response
    """

    muni_names = None
    while not muni_names:
        muni_nav.go(url)
        muni_names = muni_nav.scrape_codes(depth) # get title/chapters/articles/section
        if not muni_names:
            log(f"#### FAILED. RETRYING...\n\n")
    definitions_link = definitions
    for name in muni_names: # find definitions, if exists.
        if "definition" in name.lower():
            definitions_link = muni_names[name]
            muni_names.pop(name)
            break

    name_list = key_list(muni_names)

    log(f"## Selecting title/chapters/articles/sections...\n\n")

    prompt = f"""Query: "{query}".
Here is the list of title/chapters/articles/sections:
{name_list}."""

    response = gemini_query(client, prompt, CONFIGS["sorter"], MODELS["fast"]) # prompt for relevant title/chapters/articles/section

    response_json = json.loads(response["response"])
    response_json.sort(key=lambda x: x['relevance_rating'], reverse=True) # sorts the list based on relevance_rating

    if not len(response_json) or response_json[0]["relevance_rating"] < 4: # return None if none of the reponses are relevant enough
        return None, None, None

    for attempt in response_json:
        current_name = attempt["name"]
        if current_name in muni_names:
            log(f"### Navigating to [{current_name}]({muni_names[current_name]})\n\n")
            response = {}
            if not depth or muni_nav.contains_child(): # if theres child entries, we'll use those instead to get our answer
                if not depth:
                    depth += 1
                prompt, response, structured_response = answer(muni_nav, client, muni, muni_names[current_name], query, depth + 1, definitions_link)
            else:
                log("## ANSWERING\n\n")
                prompt = f"""Answer the following question from the link {muni_nav.get_url()}{f", with the definitions of terms stored here:{definitions_link}" if definitions_link else ""} for the municipality of {muni}.

Question: {query}"""
                response = gemini_query(client, prompt, CONFIGS["thinking"], MODELS["thinking"]) # prompt for answer to query
                if "(NONE)" in response:
                    response = None
                else:
                    structured_response = gemini_query(client, response["response"], CONFIGS["structurer"], MODELS["fast"])
            if response: # If no answer, continue, else, continue and look at next title/chapter/article/section
                return prompt, response, structured_response
    return

def main():
    state = "california"
    muni = "milpitas"
    query = "When it comes to affordable housing, are there Inclusionary Zoning rules?" 
    client = genai.Client(api_key=GOOGLE_API_KEY)
    municode_nav = municode.MuniCodeCrawler() # open crawler
    if LOGGING:
        with open("log.md", "w", encoding="utf-8") as f: # for testing purposes
            f.write(f"# LOG\n\n")

    muni_states = None
    while not muni_states:
        muni_states = municode_nav.scrape_states() # grab states
        if not muni_states:
            log(f"#### FAILED TO GET STATES, RETRYING.\n\n")
            municode_nav.go()
    
    state = state or input("State: ").lower()
    log(f"#### State: {state}\n\n")
    
    muni_cities = None
    while not muni_cities:
        municode_nav.go(muni_states[state]) # go to selected state
        muni_cities = municode_nav.scrape_cities() # grab cities
        if not muni_cities:
            log(f"#### FAILED TO GET CITIES, RETRYING.\n\n")
    #for city in muni_cities:
        #print(city)
    
    muni = muni or input("Municipality: ").lower()
    log(f"#### Municipality: {muni}\n\n")

    query = query or input("Question: ")
    log(f"#### Question: {query}\n\n-------------------\n\n")

    response = answer(municode_nav, client, muni, muni_cities[muni], query) # find relevant chapter/article and get answer
    contents = [
        types.Content(
            role="user",
            parts=[
                types.Part.from_text(text=response[0])
            ]
        ),
        types.Content(
            role="model",
            parts=[
                types.Part.from_text(text=response[1]["think"]),
                types.Part.from_text(text=response[1]["response"])
            ]
        )
    ]
    # allow user to respond and converse with model
    while (True):
        prompt = input("Respond: ")
        log(f"### User asks:\n\n{prompt}\n\n-------------------\n\n")
        contents.append(
            types.Content(
                role="user",
                parts=[
                    types.Part.from_text(text=prompt)
                ]
            )
        )
        response = gemini_query(client, contents, CONFIGS["thinking"], MODELS["thinking"])
        contents.append(
            types.Content(
                role="model",
                parts=[
                    types.Part.from_text(text=response["think"]),
                    types.Part.from_text(text=response["response"])
                ]
            )
        )

    


if __name__ == "__main__":
    main()